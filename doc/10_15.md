OK. Here is the clarified developer action plan in English, file-by-file, with the explicit rule that secrets MUST exist only in app/core/ALL_PARAMETERS.py (Single Source of Truth) and nowhere else.
Hard rule (applies to the entire repo):
All secrets/credentials MAY be read from the operating environment at runtime, but they MUST be accessed exclusively through app/core/ALL_PARAMETERS.py (via STRICT_CONFIG).
No secrets in code, logs, other modules, sample files, or the repository. No direct os.getenv(...) calls outside ALL_PARAMETERS.py. No .env committed. Ever.

0) Root & repository hygiene
.env (root)
Remove the file from the repository (contains secrets).
Rotate all exposed keys (Bybit/Telegram) immediately.
Verification: Screenshot/receipt of key rotation (Bybit = trade-only, no withdrawals). Repo secret scan shows no secrets.

.gitignore (root)
Add:
.venv
Keep: __pycache__/, *.log, .env.
Verification: Diff shows .venv added.

requirements.txt (root)
Keep packages (e.g., ntplib, bandit, pip-audit, cyclonedx-bom) but enforce deterministic installs:
1.Generate constraints.txt with exact versions + hashes.
2.Install in CI with:
3.pip install --require-hashes -r requirements.txt -c constraints.txt
Move inline comments into docs to avoid hash mismatches.
Verification: CI shows pip install fails without hashes and PASS with --require-hashes.

pyproject.toml (root)
Pin Python: requires-python = "==3.10.*".
Verification: CI matrix fails on non-3.10 runtimes.

.github/workflows/ci.yml (NEW)
Create a blocking pipeline:
Steps: ruff, mypy --strict, bandit, pip-audit (or safety), vulture, pytest --cov=app.
Fail if:
oPython ≠ 3.10
oCoverage (core) < 90%
oAny lint/type/security/dead-code fails
Emit CycloneDX SBOM as artifact.
Verification: Full CI report (all PASS). SBOM artifact present.

1) Enforce “secrets only in ALL_PARAMETERS.py (SSoT)”
app/core/ALL_PARAMETERS.py
Keep as SSoT gateway: export STRICT_CONFIG, StrictSettings, load_strict_config, reload_strict_config.
Add a module-level note (already present) that all secret access must go through this module.
Add unit tests asserting:
oNo other module imports os for the purpose of reading BYBIT_* or TELEGRAM_*.
oGrep-style test fails build if patterns like os.getenv("BYBIT_ or os.environ["BYBIT_ appear outside ALL_PARAMETERS.py and strict_config.py.
Verification: Tests PASS; static scan shows zero direct os.getenv for secrets outside ALL_PARAMETERS.py/strict_config.py.

app/core/strict_config.py
Only here (and via ALL_PARAMETERS.py) may environment values be read and mapped into STRICT_CONFIG.
Remove any prints; use system_logger.
Remove FAST mode; modes allowed = SWING/DYNAMIC/FIXED only.
PROD guard (governance):
oRequire signed release to enable PROD; otherwise trading OFF.
Permanent sources check (CRYPTORAKETEN, LUX_LEAK, SMART_CRYPTO). If missing → trading OFF.
Verification:
Tests confirm: any attempt to read secrets in other modules fails (test + grep).
Startup log shows prod_guard_block without signature.
Governance check logged; trading OFF if incomplete.

Global search & refactor (secrets misuse)
Replace all direct secret usage (e.g., os.getenv("BYBIT_API_KEY")) outside ALL_PARAMETERS.py/strict_config.py with:
from app.core.ALL_PARAMETERS import STRICT_CONFIG
STRICT_CONFIG.bybit.api_key  # example accessor
Files to change (observed direct usage):
oapp/bybit/client.py → remove _get_bybit_*() helpers that read env; only use STRICT_CONFIG.
oAny other module reading BYBIT_*/TELEGRAM_* → refactor to STRICT_CONFIG.
Verification: Repo-wide search shows no env access for secrets outside ALL_PARAMETERS.py/strict_config.py. Unit test enforces this.

2) Startup & output
start.py
Remove all print() (e.g., ~55–101, 181–228).
Use system_logger.info(...) with structured fields (e.g., event="startup").
Verification: ruff/vulture finds no print(); log sample shows JSON with required fields.

3) Bybit REST & WS
app/bybit/client.py
Replace secret reads with STRICT_CONFIG (no direct env).
Remove all print(); use system_logger.
Clock discipline:
oEnforce time offset guard: block trading if |offset| > 250 ms; target ≤ 100 ms with autosync.
Always sign with synced ts.
Never log secrets or headers containing sensitive values.
Verification: tests/core/test_ntp_sync.py PASS; logs show blocks at > ±250 ms and P95/P99 offset metrics.

app/bybit/websocket.py
Remove all print(); use system_logger.
Implement sequence gap detection + snapshot/replay:
oOn gap: event="ws_gap_detected" → pause trading → fetch REST snapshot → replay → resume.
Heartbeat: ping 30s; on pong-timeout reconnect with snapshot flow.
Verification: tests/chaos/test_chaos.py shows gap→pause→snapshot→replay→resume (PASS).

4) Signal intake & parsing
app/signals/strict_parser.py
Allow only SWING, DYNAMIC, FIXED.
Remove all FAST/SCALP/SCALPING matches (e.g., near ~222, 236–237, 414, 814, 819).
USDT-only; block others (USDC etc.) with error template to private channel.
Add Hypothesis fuzz tests (normalization, tick/step, invalids).
Verification: tests/test_parser_compliance.py PASS; invalid modes rejected with correct template.

5) Telegram templates & engine
app/telegram/engine.py
TemplateEngine.check() must require for ORDER_PLACED/POSITION_OPENED:
order_id, post_only, reduce_only, im_confirmed, source_channel_name, trigger_source (Mark|Last|Index).
Always hashtag symbols (#BTCUSDT) and use a space before % (e.g., 11 %).
Remove any leftover print().
Verification: Golden tests for all templates (exact headings/numbering/fields/format) PASS.

6) ACK gate & timeline
app/core/confirmation_gate.py
Confirm that no Telegram goes out unless Bybit retCode == 0.
Timeline journal must show BYBIT_REQUEST → BYBIT_ACK → TELEGRAM_SEND with order_id, im_confirmed, leverage.
Verification: Test 1 ACK-Gate evidence (logs + Telegram screenshots) PASS.

7) Numeric discipline
app/core/decimal_utils.py
Keep: ROUND_DOWN for price, ROUND_FLOOR for qty.
Repo-wide: migrate any manual .quantize(...) on price/qty to these helpers.
Verification: Search shows no stray .quantize calls; unit tests PASS.

8) Risk, IM & leverage
app/core/leverage_policy.py
Remove FAST mode logic; enforce:
oSWING = x6.00
oDYNAMIC = ≥ x7.50 (two decimals)
oFIXED = explicit; forbid values between 6 and 7.5
If SL missing: set auto-SL −2 % from OEP and lock leverage x10 for that safety case (not as a “mode”).
Enforce max 100 concurrent trades (hard cap + alarm).
Verification: tests/test_leverage_policy.py PASS; risk report shows exact calcs including fees/funding/slippage.

9) Pyramid & ladder (OEP-based; harmonize)
app/core/oep_pyramid.py (create if missing)
Implement exact OEP-based levels:
+1.5 %: IM check = 20 USDT if any TP hit
+2.3 %: SL → BE + 0.0015 %
+2.4 %: Leverage → max (to x50); recompute position
+2.5 %: IM → 40 USDT total
+4 %: IM → 60; +6 %: 80; +8.6 %: 100
Critical harmonization with templates:
Templates require “Pyramid Step 4” = leverage-only (forbid qty_add/im_add).
The ladder requires +2.5 % = IM 40 USDT.
Ensure step numbering and conditions match in code and templates so 2.4 % is Step 4 (leverage-only) and 2.5 % is next step (IM→40).
Steps must be atomic: journal→Bybit-ack→Telegram. Missing leverage ack ⇒ rollback/block.
Verification: Journal + Telegram + Bybit state for each step; timeout test PASS.

10) SL/TP & trailing
app/core/tpsl_policy.py (or consolidate existing intelligent TPSL)
SL/TP exactly as in signal; all closing orders: CloseOnTrigger + ReduceOnly.
TP2 hit ⇒ SL→BE + 0.0015 % (driven by WS event).
Trailing: activate at +6.1 %; keep SL 2.5 % behind high/low; after activation only trailer controls SL.
Include trigger_source (Mark|Last|Index) in payload and templates.
Verification: Simulation + WS events update SL correctly; golden tests include trigger_source.

11) Hedge & re-entry
app/trade/manager.py & app/trade/websocket_handlers.py
Hedge at −2 % against position: open opposite direction; size 100 % of original; TP=original SL, SL=OEP.
Re-entry: dual-limit up to 3 tries with exponential backoff; then pause until a new external signal.
All Telegram notifications after Bybit confirmation (through ConfirmationGate).
Verification: WS simulation + journal PASS; retries produce no duplicates.

12) Market guards & symbols
app/core/symbol_registry.py, app/core/symbol_filter.py, app/core/market_guards.py
Auto-discover all USDT pairs (sync with Bybit).
Validate tick/step/min/max notional/qty before submit; block + error template if violated.
PDR price band, spread guard (spread/mid > threshold ⇒ block), liquidity guard (BBO volume < min ⇒ block).
Auto-split if qty > maxOrderQty (deterministic suborders).
Verification: Symbol tests + logs show blocks and correct splitting.

13) Logging, journal & integrity
app/core/logging.py
JSON-only logging with secret scrubbing (regex).
Required fields on every critical event:
ts,event,signal_id,order_id,clientOrderId,symbol,side,qty,price,IM,leverage,latency,error_code,OEP_hash.
Verification: Negative test proves no secret leaks; samples show all required fields.

app/core/journal.py
Append-only journal with chain-hash per entry (SHA256(prev_hash + entry)).
fsync after critical writes (order→ack, fill, close).
Reconciliation at startup + periodic: journal ↔ Bybit; clean orphans.
Verification: tests/core/test_journal.py verifies chain & crash recovery.

14) Health & operations
app/api/health.py
/health, /status, /metrics must be green before trading=ON.
Dependency gate: trading=OFF if any dependency (Bybit REST/WS, Telegram, DB/journal) is DOWN.
Verification: Induced outage → trading OFF + alarm; recovery → trading ON.

15) Scheduler & reports
app/reports/scheduler_v2.py
Ensure no print(); use logger.
Daily 08:00 (Europe/Stockholm) & Weekly Sat 22:00 (Europe/Stockholm):
oDaily: trades count, winrate, PnL, re-entries, hedges, pyramid levels.
oWeekly: above + top symbols.
System heartbeat every 30 minutes (template-conformant).
Verification: Scheduling logs + sample reports; idempotent, no duplicate posts.

16) Test suite (blocking)
tests/* (augment existing tests)
Coverage ≥ 90 % (core).
Golden tests for all Telegram templates (exact headings/numbering/fields/format).
Integration (Bybit Testnet & Telegram sandbox): place→ack→partial fill→SL/TP→cancel→close; subscribe/resubscribe/resync.
Chaos: WS drop, 429/5xx storms, clock drift, process restart → prove idempotence/exact-once.
Property-based (Hypothesis): parser/quantization (positive/negative, edge ticks/steps).
Persistence robustness: crash in the middle of journal write → correct recovery.
Verification: pytest report PASS; coverage.xml shows ≥ 90 % (core). CI PASS.

17) Deliverables & final acceptance
SBOM (CycloneDX) per release.
Full CI report (lint/type/sec/tests/coverage).
NTP log + latency profile (P95/P99: place→ack, ack→fill, WS gap).
72h log sample (zero secret leaks).
Runbook & on-call (versioned).
Rollback plan tested in staging (image tag-freeze, data migration).
Testnet↔Mainnet guard — PROD requires signature.
Final must-pass checks:
1.Test 1 – ACK-Gate Compliance: Timeline evidence that all “success” Telegram steps occur after Bybit ACK/WS event.
2.Test 2 – OEP Integrity: Journal + OEP_hash prove pyramid/ladder/trailing/SL-move/leverage/IM all use OEP only (never avg_entry).
3.Test 3 – Operations & Security: No secret leaks, green health, correct resync, idempotence, rate-limit compliance, correct reports in Europe/Stockholm.
4.Pyramid harmonization: “Pyramid Step 4” = leverage-only in templates; +2.5 % = IM 40 USDT in ladder; numbering aligned across code & templates.
5.Templates: Golden tests PASS; trigger_source visible and matches Bybit payload.
6.Secrets policy: The only place allowed to access secrets is via app/core/ALL_PARAMETERS.py (SSoT). No copies, no direct env reads elsewhere, no secrets in repo/logs/configs.

Quick “where to change” map (non-exhaustive, high-impact)
app/bybit/client.py — remove direct env helpers; use STRICT_CONFIG; replace prints; add time skew guard.
app/bybit/websocket.py — remove prints; add seq gap + snapshot/replay; heartbeat handling.
app/core/strict_config.py — remove FAST; PROD guard; permanent sources; no prints.
app/core/ALL_PARAMETERS.py — SSoT only access point for secrets; add tests to forbid env access elsewhere.
app/signals/strict_parser.py — allow only SWING/DYNAMIC/FIXED; USDT-only.
app/telegram/engine.py — enforce trigger_source; hashtag & percent spacing; no prints.
app/core/leverage_policy.py — no FAST; add “missing SL ⇒ auto-SL −2 % & lock x10” (not a mode).
app/core/journal.py — chain-hash + fsync + reconciliation & orphan cleanup.
app/reports/scheduler_v2.py — logger only; heartbeat every 30 minutes.
.github/workflows/ci.yml — blocking CI with hashes, coverage, security, SBOM.

One-sentence policy reminder:
Secrets must exist only behind the STRICT_CONFIG interface exported by app/core/ALL_PARAMETERS.py — nowhere else in code, config, repository, or logs.
Du sade:
översätt till engelska
ChatGPT sade:
Tänkte i 4 sekunder
Here’s the full English version, with the explicit rule that secrets MUST exist only behind app/core/ALL_PARAMETERS.py (Single Source of Truth) and nowhere else.

Hard rule (applies to the entire repo):
All secrets/credentials MAY be read from the operating environment at runtime, but they MUST be accessed exclusively through app/core/ALL_PARAMETERS.py (via STRICT_CONFIG).
No secrets in code, logs, other modules, sample files, or the repository. No direct os.getenv(...) calls outside ALL_PARAMETERS.py/strict_config.py. No .env committed.

0) Root & repository hygiene
.env (root)
Remove the file from the repository (contains secrets).
Rotate all exposed keys (Bybit/Telegram) immediately.
Verification: Screenshot/receipt of key rotation (Bybit = trade-only, no withdrawals). Repo secret scan shows no secrets.
.gitignore (root)
Add:
.venv
Keep: __pycache__/, *.log, .env.
Verification: Diff shows .venv added.
requirements.txt (root)
Enforce deterministic installs:
1.Generate constraints.txt with exact versions + hashes.
2.Install in CI with:
3.pip install --require-hashes -r requirements.txt -c constraints.txt
Move inline comments into docs to avoid hash mismatches.
Verification: CI shows pip install fails without hashes and PASS with --require-hashes.
pyproject.toml (root)
Pin Python: requires-python = "==3.10.*".
Verification: CI matrix fails on non-3.10 runtimes.
.github/workflows/ci.yml (NEW)
Create a blocking pipeline:
Steps: ruff, mypy --strict, bandit, pip-audit (or safety), vulture, pytest --cov=app.
Fail if:
oPython ≠ 3.10
oCoverage (core) < 90%
oAny lint/type/security/dead-code fails
Emit CycloneDX SBOM as artifact.
Verification: Full CI report (all PASS). SBOM artifact present.

1) Enforce “secrets only in ALL_PARAMETERS.py (SSoT)”
app/core/ALL_PARAMETERS.py
Keep as SSoT gateway: export STRICT_CONFIG, StrictSettings, load_strict_config, reload_strict_config.
Add a module-level note (already present) that all secret access must go through this module.
Add unit tests asserting:
oNo other module imports os to read BYBIT_*/TELEGRAM_*.
oGrep-style test fails build if os.getenv("BYBIT_ / os.environ["BYBIT_ occurs outside ALL_PARAMETERS.py/strict_config.py.
Verification: Tests PASS; static scan shows zero direct os.getenv for secrets outside the SSoT.
app/core/strict_config.py
Only here (and via ALL_PARAMETERS.py) may environment values be read and mapped into STRICT_CONFIG.
Remove any prints; use system_logger.
Remove FAST mode; allowed modes = SWING/DYNAMIC/FIXED only.
PROD guard (governance): require a signed release to enable PROD; otherwise trading OFF.
Permanent sources check (CRYPTORAKETEN, LUX_LEAK, SMART_CRYPTO). If missing → trading OFF.
Verification:
Tests confirm: any attempt to read secrets elsewhere fails (test + grep).
Startup log shows prod_guard_block without signature.
Governance check logged; trading OFF if incomplete.
Repo-wide refactor (secrets misuse)
Replace all direct secret reads (e.g., os.getenv("BYBIT_API_KEY")) outside ALL_PARAMETERS.py/strict_config.py with:
from app.core.ALL_PARAMETERS import STRICT_CONFIG
STRICT_CONFIG.bybit.api_key  # example accessor
Files to fix (seen reading env directly):
app/bybit/client.py (remove _get_bybit_*() env helpers; only use STRICT_CONFIG).
Any other module touching BYBIT_*/TELEGRAM_* → refactor to STRICT_CONFIG.
Verification: Repo search shows no env access for secrets outside SSoT. Unit test enforces this.

2) Startup & output
start.py
Remove all print() (e.g., ~55–101, 181–228).
Use system_logger.info(...) with structured fields (e.g., event="startup").
Verification: ruff/vulture find no print(); log sample shows JSON with required fields.

3) Bybit REST & WS
app/bybit/client.py
Use STRICT_CONFIG for secrets (no direct env).
Remove all print(); use system_logger.
Clock discipline:
oBlock trading if |offset| > 250 ms; target ≤ 100 ms with autosync.
Always sign with synced timestamp.
Never log secrets or secret-bearing headers.
Verification: tests/core/test_ntp_sync.py PASS; logs show blocks at > ±250 ms and P95/P99 offset metrics.
app/bybit/websocket.py
Remove all print(); use system_logger.
Implement sequence gap detection + snapshot/replay:
oOn gap: event="ws_gap_detected" → pause trading → fetch REST snapshot → replay → resume.
Heartbeat: ping 30s; on pong-timeout reconnect with snapshot flow.
Verification: tests/chaos/test_chaos.py shows gap→pause→snapshot→replay→resume (PASS).

4) Signal intake & parsing
app/signals/strict_parser.py
Allow only SWING, DYNAMIC, FIXED.
Remove all FAST/SCALP/SCALPING matches (e.g., ~222, 236–237, 414, 814, 819).
USDT-only; block others (USDC etc.) with error template to private channel.
Add Hypothesis fuzz tests (normalization, tick/step, invalids).
Verification: tests/test_parser_compliance.py PASS; invalid modes rejected with correct template.

5) Telegram templates & engine
app/telegram/engine.py
TemplateEngine.check() must require for ORDER_PLACED/POSITION_OPENED:
order_id, post_only, reduce_only, im_confirmed, source_channel_name, trigger_source (Mark|Last|Index).
Always hashtag symbols (#BTCUSDT) and use a space before % (e.g., 11 %).
Remove any leftover print().
Verification: Golden tests for all templates (exact headings/numbering/fields/format) PASS.

6) ACK gate & timeline
app/core/confirmation_gate.py
No Telegram goes out unless Bybit retCode == 0.
Timeline shows BYBIT_REQUEST → BYBIT_ACK → TELEGRAM_SEND with order_id, im_confirmed, leverage.
Verification: Test 1 ACK-Gate evidence (logs + Telegram screenshots) PASS.

7) Numeric discipline
app/core/decimal_utils.py
Keep: ROUND_DOWN for price, ROUND_FLOOR for qty.
Repo-wide: migrate any manual .quantize(...) on price/qty to these helpers.
Verification: Search shows no stray .quantize; unit tests PASS.

8) Risk, IM & leverage
app/core/leverage_policy.py
Remove FAST mode logic; enforce:
oSWING = x6.00
oDYNAMIC = ≥ x7.50 (two decimals)
oFIXED = explicit; forbid values between 6 and 7.5
If SL missing: set auto-SL −2 % from OEP and lock leverage x10 for that safety case (not as a mode).
Enforce max 100 concurrent trades (hard cap + alarm).
Verification: tests/test_leverage_policy.py PASS; risk report shows exact calcs including fees/funding/slippage.

9) Pyramid & ladder (OEP-based; harmonize)
app/core/oep_pyramid.py (create if missing)
Implement exact OEP-based levels:
+1.5 %: IM check = 20 USDT if any TP hit
+2.3 %: SL → BE + 0.0015 %
+2.4 %: Leverage → max (to x50); recompute position
+2.5 %: IM → 40 USDT total
+4 %: IM → 60; +6 %: 80; +8.6 %: 100
Harmonize with templates:
Templates require “Pyramid Step 4” = leverage-only (forbid qty_add/im_add).
Ladder requires +2.5 % = IM 40 USDT.
Ensure numbering and conditions match in code and templates: 2.4 % is Step 4 (leverage-only) and 2.5 % is next step (IM→40).
Steps must be atomic: journal→Bybit-ack→Telegram. Missing leverage ack ⇒ rollback/block.
Verification: Journal + Telegram + Bybit state for each step; timeout test PASS.

10) SL/TP & trailing
app/core/tpsl_policy.py (or consolidate existing intelligent TPSL)
SL/TP exactly as in signal; closing orders use CloseOnTrigger + ReduceOnly.
TP2 hit ⇒ SL→BE + 0.0015 % (via WS event).
Trailing: activate at +6.1 %; keep SL 2.5 % behind high/low; after activation only the trailer controls SL.
Include trigger_source (Mark|Last|Index) in payload and templates.
Verification: Simulation + WS events update SL correctly; golden tests include trigger_source.

11) Hedge & re-entry
app/trade/manager.py & app/trade/websocket_handlers.py
Hedge at −2 % against position: open opposite direction; size 100 % of original; TP=original SL, SL=OEP.
Re-entry: dual-limit up to 3 tries with exponential backoff; then pause until a new external signal.
All Telegram notifications after Bybit confirmation (via ConfirmationGate).
Verification: WS simulation + journal PASS; retries produce no duplicates.

12) Market guards & symbols
app/core/symbol_registry.py, app/core/symbol_filter.py, app/core/market_guards.py
Auto-discover all USDT pairs (sync with Bybit).
Validate tick/step/min/max notional/qty before submit; block + error template if violated.
PDR price band, spread guard (spread/mid > threshold ⇒ block), liquidity guard (BBO volume < min ⇒ block).
Auto-split if qty > maxOrderQty (deterministic suborders).
Verification: Symbol tests + logs show blocks and correct splitting.

13) Logging, journal & integrity
app/core/logging.py
JSON-only logging with secret scrubbing (regex).
Required fields:
ts,event,signal_id,order_id,clientOrderId,symbol,side,qty,price,IM,leverage,latency,error_code,OEP_hash.
Verification: Negative test proves no secret leaks; samples show all required fields.
app/core/journal.py
Append-only journal with chain-hash per entry (SHA256(prev_hash + entry)).
fsync after critical writes (order→ack, fill, close).
Reconciliation at startup + periodic: journal ↔ Bybit; clean orphans.
Verification: tests/core/test_journal.py verifies chain & crash recovery.

14) Health & operations
app/api/health.py
/health, /status, /metrics must be green before trading=ON.
Dependency gate: trading=OFF if any dependency (Bybit REST/WS, Telegram, DB/journal) is DOWN.
Verification: Induced outage → trading OFF + alarm; recovery → trading ON.

15) Scheduler & reports
app/reports/scheduler_v2.py
Use logger (no print()).
Daily 08:00 (Europe/Stockholm) & Weekly Sat 22:00 (Europe/Stockholm):
oDaily: trades count, winrate, PnL, re-entries, hedges, pyramid levels.
oWeekly: above + top symbols.
System heartbeat every 30 minutes (template-conformant).
Verification: Scheduling logs + sample reports; idempotent, no duplicates.

16) Test suite (blocking)
tests/* (augment existing tests)
Coverage ≥ 90 % (core).
Golden tests for all Telegram templates (exact headings/numbering/fields/format).
Integration (Bybit Testnet & Telegram sandbox): place→ack→partial fill→SL/TP→cancel→close; subscribe/resubscribe/resync.
Chaos: WS drop, 429/5xx storms, clock drift, process restart → prove idempotence/exact-once.
Property-based (Hypothesis): parser/quantization (positive/negative, edge ticks/steps).
Persistence robustness: crash mid journal write → correct recovery.
Verification: pytest report PASS; coverage.xml shows ≥ 90 % (core). CI PASS.

17) Deliverables & final acceptance
SBOM (CycloneDX) per release.
Full CI report (lint/type/sec/tests/coverage).
NTP log + latency profile (P95/P99: place→ack, ack→fill, WS gap).
72h log sample (zero secret leaks).
Runbook & on-call (versioned).
Rollback plan tested in staging (image tag-freeze, data migration).
Testnet↔Mainnet guard — PROD requires signature.
Final must-pass checks:
1.Test 1 – ACK-Gate Compliance: All “success” Telegram steps occur after Bybit ACK/WS event (timeline evidence).
2.Test 2 – OEP Integrity: Journal + OEP_hash prove pyramid/ladder/trailing/SL-move/leverage/IM use OEP only (never avg_entry).
3.Test 3 – Operations & Security: No secret leaks, green health, correct resync, idempotence, rate-limit compliance, correct reports (Europe/Stockholm).
4.Pyramid harmonization: “Pyramid Step 4” = leverage-only in templates; +2.5 % = IM 40 USDT in ladder; numbering aligned.
5.Templates: Golden tests PASS; trigger_source matches Bybit payload.
6.Secrets policy: The only place allowed to access secrets is via app/core/ALL_PARAMETERS.py (SSoT). No secrets anywhere else.


Below is the rewritten, complete action/review checklist that ONLY points to the ZIP codebase (files, modules, functions, approximate lines) the developer must change. For each item I specify: File(s) → Section/Function → Action → Verification (tests/logic).
I reference the uploaded code and use exact function names/line ranges where available.

1) Always place two limit entry orders (50/50 or ±0.1%) and ensure Post-Only
Files:
app/bybit/client.py → BybitClient.create_order (approx. 0190–0270), BybitClient.create_batch_orders (if present), BybitClient._normalize_order_params (if present).
app/core/strict_fsm.py → TradeFSM._place_entry_orders (approx. 0500–0580), TradeFSM._prepare_entry_params (approx. 0450–0500).
Action:
Enforce creation of two entry limit orders per signal (either 50/50 on two distinct prices, or entry + ±0.1% offset).
Set post_only=True and apply tick/lot rounding before placing.
If only one entry price is provided, compute the second with ±0.1% offset before the API call.
Verification:
Run scripts/validate_order_params.py to confirm post_only==True, two distinct orderLinkIds, and valid price/qty (tick/lot).
Run tests: tests/test_client_spec_compliance.py and tests/test_parser_compliance.py.
E2E in DEMO via app/tools/demo_trader.py (confirm two returned orderIds).

2) Reduce-Only only on exits (never on entries)
Files:
app/bybit/client.py → create_order, create_tpsl (approx. 0300–0420).
app/core/strict_fsm.py → TradeFSM._place_exit_orders (approx. 0590–0670), TradeFSM._validate_flags (if present).
Action:
Hard-enforce: entry orders must not have reduce_only=True.
Exits (TP/SL) must have reduce_only=True.
Verification:
scripts/validate_order_params.py should flag any entry with reduce_only==True.
tests/test_tpsl_retry.py + tests/test_client_spec_compliance.py must pass without reduction flag errors.

3) Consistent trigger source (Mark/Last) for all SL/TP
Files:
app/core/intelligent_tpsl_fixed_v3.py (entire file—SL/TP policy and trigger fields).
app/core/simulated_tpsl.py → class SimulatedTPSLManager (approx. 0010–0280).
app/core/strict_fsm.py → TradeFSM._place_exit_orders.
Action:
Introduce/stabilize a global config (e.g., TRIGGER_SOURCE="Last" or "Mark") and use the same value in all create_tpsl/create_stop calls.
Validate mapping to Bybit’s triggerBy.
Verification:
tests/test_client_32_checklist.py (trigger & param checks) + tests/test_tpsl_retry.py.
Internal logs must always print the chosen trigger_source before placing.

4) All percentage calculations (TP/SL/BE/trailing) must use original_entry_price (immutable)
Files:
app/core/strict_state.py → class TradeState (approx. 0006–0090) – add original_entry_price set on first fill.
app/trade/manager.py → position monitoring function(s) – read from original_entry_price.
app/core/pnl_calculator.py, app/core/position_calculator.py – ensure % logic references original_entry_price.
Action:
On first fill, persist original_entry_price in TradeState and never overwrite it on pyramid/hedge/re-entry.
All % logic (BE +0.0015%, trailing, TP levels) must compute from original_entry_price.
Verification:
Unit tests in tests/test_strategies.py (breakeven, trailing) and tests/test_leverage_policy.py (indirectly).
Add a test to confirm pyramiding does not change original_entry_price and derived % levels remain consistent.

5) Pyramid Step 4 = leverage only (no qty/IM)
Files:
app/strategies/pyramid_v2.py (entire file—pyramid levels).
app/core/leverage_policy.py (approx. 0001–0120).
Action:
In pyramid_v2.py: when step==4, forbid changes to qty and IM; change only leverage (max x50).
In leverage_policy.py: block any IM/qty change when step==4.
Verification:
tests/test_strategies.py (pyramid) + tests/test_leverage_policy.py must explicitly test step 4.
Negative test: inject qty_add at step 4 → expect ValueError.

6) Entry orders must rest in the book (Maker join: ticks/offset)
Files:
app/bybit/client.py → order parameters and price rounding.
app/core/strict_fsm.py → _prepare_entry_params / _place_entry_orders.
app/config/trading_config.py → config values maker_join_ticks, offset_pct.
Action:
In _prepare_entry_params, move limit price away from taker level using maker_join_ticks before API call.
Add fallback (±1–2 ticks) retry if Bybit rejects as would-be-taker/post-only.
Verification:
scripts/diagnose_signal_failures.py should report 0 instances where an entry fails to rest as maker under normal spreads.
tests/test_symbol_filter.py and tests/test_client_spec_compliance.py must remain green.

7) Position becomes OPENED only on actual fill (qty>0) – state-machine gate
Files:
app/bybit/websocket.py → private fills/position updates.
app/core/strict_fsm.py → TradeFSM._on_fill_event, TradeFSM._open_position_if_filled.
app/bybit/client.py → polling fallback (if WS event is missing).
Action:
Implement a gate: TradeFSM sets “OPENED” only when WS/poll reports qty>0.
Defer subsequent TP/SL placement until OPENED is confirmed (if not already separated).
Verification:
tests/core/test_timeline_logger.py must show the sequence: request → ACK (retCode=0) → FILL/qty>0 → OPENED.
tests/test_client_32_checklist.py should assert event ordering (add if missing).

8) TPSL place/restore must be deterministic and retried properly
Files:
app/core/intelligent_tpsl_fixed_v3.py → main SL/TP logic.
app/core/simulated_tpsl.py → DEMO/low-risk fallback.
app/core/strict_fsm.py → TradeFSM._place_exit_orders, TradeFSM._reconcile_exits.
Action:
Idempotent place/update: on transient errors (rate limit/timeout), retry n times with backoff.
On reconnect: run reconcile to ensure SL/TP exist and match config (levels and reduce_only).
Verification:
tests/test_tpsl_retry.py must pass, demonstrating retries.
Simulate WS reconnect (extend tests or add one) and confirm reconcile_exits() runs.

9) Tick/lot and quantity unit consistency (do not mix contracts vs USDT-notional)
Files:
app/core/position_calculator.py → calc_position_size, normalize_qty (approx. 0010–0130).
app/core/pnl_calculator.py → entire file (in/out units).
Action:
Lock one quantity unit end-to-end (e.g., contracts) and convert only at the API boundary.
Add asserts/value checks on min_qty, qty_step, tick_size.
Verification:
tests/test_symbol_filter.py and tests/test_client_spec_compliance.py must pass; add a test comparing expected contracts to symbol metadata.

10) Strict leverage policy per mode (SWING/DYNAMIC/FAST)
Files:
app/core/leverage_policy.py (entire file).
app/bybit/client.py → BybitClient.set_leverage (approx. 0550–0600).
Action:
Enforce: SWING=x6, FAST=x10, DYNAMIC per policy in the file. Any deviation → block order.
In set_leverage: verify Bybit retCode==0 and returned effectiveLeverage equals the requested value.
Verification:
tests/test_leverage_policy.py must pass; add negative tests for disallowed values.

11) Capacity limits and cleanup of stale orders (timeout 24h/6d per policy)
Files:
app/core/trade_limiter.py → max active trades.
app/core/bybit_data_sync.py → fetch open orders/positions and cleanup.
app/core/strict_fsm.py → scheduled check TradeFSM._gc_stale_orders.
Action:
Block new trades when TradeLimiter hits the limit; return a specific error at code level.
Implement time-based cleanup for unfilled entries.
Verification:
tests/test_modes.py + tests/test_error_fixes.py (capacity/error paths).
Run scripts/diagnose_signal_failures.py and confirm “0 stale orders” post-cleanup.

12) Reconnect/restart: re-sync positions and exits before resuming
Files:
app/bybit/websocket.py → on_open/on_reconnect hooks.
app/core/bybit_data_sync.py → sync_positions_and_orders.
app/core/strict_fsm.py → TradeFSM._on_reconnect, TradeFSM._reconcile_exits.
Action:
On reconnect/start:
1.Read Bybit positions and open orders.
2.Restore internal state (TradeState) for each trade.
3.Run reconcile_exits().
Verification:
Add an integration test that simulates restart and shows SL/TP restored after sync.

13) Return codes/error mapping: correct cause → correct handler (code-level, not Telegram)
Files:
app/core/retcodes.py → canonical mapping.
app/core/errors.py → central error policy (pauses/backoff/circuit breaker).
app/core/circuit_breaker.py → stop flow on repeated failures.
Action:
Map Bybit errors (insufficient margin, parameters error, would-be-taker) to specific handlers (e.g., reduce qty, nudge tick, backoff).
Log exact retCode/retMsg per call in timeline_logger.
Verification:
tests/test_error_fixes.py should include scenarios for each main category.
tests/core/test_timeline_logger.py must show the full event chain including errors.

14) Timestamps & NTP – ensure signature and recvWindow are valid
Files:
app/bybit/client.py → _ts, _headers, _sign (approx. 0043–0065).
app/core/ntp_sync.py → entire file.
Action:
Ensure NTP sync runs before private calls; adjust recvWindow and handle Bybit “timestamp expired/skew”.
Verification:
tests/core/test_ntp_sync.py must pass.
Negative test: simulate 1–2s offset → expect automatic correction.

15) Clear FSM lifecycle (ACK-gate → FILL → OPENED → TPSL → CLOSE)
Files:
app/core/strict_fsm.py → entire TradeFSM class (many methods; see function index below).
app/core/timeline_logger.py → lifecycle logging.
Action:
Ensure no path can skip the FILL step.
Document in code comments and log with timeline_logger.log_event().
Verification (function index in strict_fsm.py):
TradeFSM._place_entry_orders
TradeFSM._on_fill_event
TradeFSM._open_position_if_filled
TradeFSM._place_exit_orders
TradeFSM._check_trailing_stop
TradeFSM._move_to_breakeven
TradeFSM._record_trade_completion
TradeFSM._emergency_close
(AST scan indicated approx. 0580–0918 for these methods in your file.)

16) Symbol filtering & sizing – block unsupported markets
Files:
app/config/trading_config.py → BLACKLISTED_SYMBOLS, etc.
app/core/symbol_filter.py → policies for min/max, leverage support, tick/lot.
Action:
Block symbols lacking full metadata or with unsupported derivatives type (to avoid wrong qty/tick/triggerBy).
Verification:
tests/test_symbol_filter.py must pass with selection tests.

17) Diagnostics & validation scripts (developer local runs)
Files:
scripts/validate_order_params.py
scripts/diagnose_signal_failures.py
app/tools/demo_trader.py
Action:
Run the validator against all placed orders in DEMO and collect deviations.
Ensure diagnose_signal_failures.py is part of CI and returns 0 criticals.
Verification:
Include these scripts in CI; assert exit code 0.

Deep dive: function index (AST extraction reference)
app/bybit/client.py – critical sections:
BybitClient.create_order (entry/exit parameter discipline, Post/Reduce)
BybitClient.create_tpsl (SL/TP triggerBy/Reduce-Only)
BybitClient.set_leverage (policy enforcement, retCode check)
BybitClient.cancel_order / cancel_all (cleanup)
_ts, _headers, _sign (timestamp/recvWindow/signature)
app/core/strict_fsm.py – core flow:
_prepare_entry_params, _place_entry_orders, _on_fill_event, _open_position_if_filled, _place_exit_orders, _move_to_breakeven, _check_trailing_stop, _record_trade_completion, _emergency_close.
Supporting modules in app/core:
position_calculator.py (qty/tick/lot)
pnl_calculator.py (% vs USDT, VWAP)
leverage_policy.py (mode→leverage)
simulated_tpsl.py (test/DEMO fallback)
bybit_data_sync.py (reconcile after reconnect)
retcodes.py, errors.py, circuit_breaker.py, timeline_logger.py.

How to review and deliver the changes
1.Implement the code changes per item above in the specified files/functions.
2.Run tests:
opytest -q tests/test_client_spec_compliance.py tests/test_tpsl_retry.py tests/test_strategies.py tests/test_symbol_filter.py tests/test_leverage_policy.py tests/core/test_timeline_logger.py
3.Run scripts:
opython scripts/validate_order_params.py
opython scripts/diagnose_signal_failures.py
4.Confirm in DEMO (app/tools/demo_trader.py) that:
oTwo Post-Only entries are placed.
oThe position is marked OPENED only after an actual fill.
oExits (SL/TP) are Reduce-Only and use a consistent trigger source.
oPyramid step 4 changes only leverage.
This is a final, developer-exact plan that targets the ZIP codebase only—no Telegram templates or external docs. If you want, I can also provide ready-to-apply code diffs (per function above) as a patch bundle.
